import pyodbc 

from .dbconnector import *

class metadatalist(dbconnector):
#TODO: Presenter og editer data i en mange til mange kobling (fx projects / topics )
#TODO: Editer data med foreign key-kobling - bruk en dropdownbox


    
    def __init__(self,tablename,name=None,shortname=None,username=None,description=None,id=None,req=None):
        # Initieres helst med req - som kan hentes fra request.form
        # Todo: Handle checkboxes - v='on'
        self.tablename=tablename
        if req !=None:
            for k,v in req.items():
                if v=='':
                    setattr(self,k,None)
                else:
                    setattr(self,k,v)
        else: # setting by passing in  values explicitely 
            self.name=name
            self.shortname=shortname
            self.description=description
            self.username=username
            self.id=id
        try:
            if self.shortname != None:
                self.shortname=self.shortname.upper()
        except AttributeError:
            # if so, just ignore it - there is no shortname - maybe better to explicitely ask if the attribute exists
            pass            
        self.columns=None
        self.colnames=None
        self.cursor=self.connecttodb()
    
    
    def checkexists(self,req,uniquefields=["name","shortname"]):
        # Checking if a record already exists.
        # uniquefields: list of fields that must be unique
        if self.colnames==None:
            self.getcolnames()
        fieldlist=[]
        for f in uniquefields:
            if f in self.colnames: # Only if the field exists in the table. 
                fieldlist.append(f+"=?")
        sql = "select count (id) from "+self.tablename +" where "+ " or ".join(fieldlist)
        print(sql)
        self.cursor.execute(sql,self.name,self.shortname)
        return(self.cursor.fetchall()[0][0])
        
    
    def search(self,partial=True,readable=False):
        # partial - searches for a string anywhere within a field
        # readable - using a view to make a readable list rather than listing id values.
        # TODO: Return a limited number of values
        fields=[]
        values=[]
        for k,v in self.hash().items():
            # print(k,v)
            if v != None:
                v=str(v)
                if partial:
                    # Partial match
                    # Todo: This will not work for non-text fields. 
                    fields.append(k+" like ?")
                    values.append("%%"+v+"%%")
                else:
                    fields.append(k+"=?")
                    values.append(v)
        
        sql = "select id,"+",".join(self.dynfields()) +" from "+self.tablename       
        if readable: 
        # No! adding _full on self.tablename will mess up other things. The table is the basic unit
            sql=sql+"_full"
        if len(values)>0: 
        # If no search value is given, the whole table is to be returned. 
        # Presently that is desired, but it may be changed later on
            sql=sql+" where "+(" and ".join(fields))
        self.cursor.execute(sql,values)
        set = self.cursor.fetchall()
        return(set)
   
        
    
    def dynfields(self):
        # Lists the user-definable fiels a table
        if self.colnames==None:
            self.getcolnames()
        fields=self.colnames
        # In the tables id is always an autogenerated number, inserted is a timestamp for when a record was created 
        for field in ['id','inserted']:
            try:
                fields.remove(field)
            except:
                pass # The field did not exist - I do not care
        return(fields)
        
    def fields(self):
        # Returns a list of all fields in the actual table
        # Deprecated: use self.colnames in stead.
        print("BOOO! Called field(self) in staticdata.py ****** - rewrite to use self.colnames")
        if self.colnames==None:
            self.getcolnames()
        return(self.colnames)
        
        
    def save(self):
        # Saves a record. Run checkexists before to see that the record is unique if that is needed
        fields=self.dynfields()
        sql="insert into "+self.tablename +"("+",".join(fields)+") values("+",".join('?'*len(fields)) +")"
        param=[]
        for field in fields:
            param.append(getattr(self,field))
        self.cursor.execute(sql,param)
        self.cursor.commit()
        print("Saving")